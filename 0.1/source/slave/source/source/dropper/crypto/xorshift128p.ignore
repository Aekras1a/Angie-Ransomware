#include <config.h>
#include <crypto/xorshift128p.h>
#include <crypto/fnv1a.h>

// TODO: use crc32

static DWORD dwXorshiftState[4] = { RTLP_LCG_DWORD, RTLP_LCG_DWORD, RTLP_LCG_DWORD, RTLP_LCG_DWORD };

QWORD
Xorshift128Next(VOID)
{
    QWORD qw1 = ((PQWORD)&dwXorshiftState)[0];
    QWORD qw0 = ((PQWORD)&dwXorshiftState)[1];
    QWORD result = qw0 + qw1;
    ((PQWORD)&dwXorshiftState)[0] = qw0;
    qw1 ^= qw1 << 23;
    ((PQWORD)&dwXorshiftState)[1] = qw1 ^ qw0 ^ (qw1 >> 18) ^ (qw0 >> 5);

    return result;
}

VOID
Initxorshift128p(VOID)
{
    $DLOG0(DLG_FLT_INFO, "Initializing xorshift128p");

#if SCFG_RANDOM_FORCE_NON_RDRAND == ON
    if (FALSE) {
#elif SCFG_RANDOM_FORCE_RDRAND == ON
    if (TRUE) {
#else
    if (RtlpIsProcessorFeaturePresent(PF_RDRAND_INSTRUCTION_AVAILABLE)) {
#endif
        $DLOG2(DLG_FLT_DEFAULT, "Seed method \"RDRAND\"");

        PRAGMA_LOOP_UNROLL
        for (ULONG_PTR i = 0; i != 4; i++) {
            while (!_rdrand32_step((PVOID)&dwXorshiftState[i]));
        }
    } else {
        $DLOG2(DLG_FLT_DEFAULT, "Seed method \"TIME\"");
       
        PTEB Teb = RtlpGetTeb();
        dwXorshiftState[0] = Fnv1aDwordInline(RtlpUserShared()->SystemTime.LowPart      ^ (Teb->ClientId.UniqueThread            << 16), sizeof(DWORD));
        dwXorshiftState[1] = Fnv1aDwordInline(RtlpUserShared()->InterruptTime.LowPart   ^ (RtlpUserShared()->TickCount.LowPart   << 16), sizeof(DWORD));
        dwXorshiftState[2] = Fnv1aDwordInline(RtlpUserShared()->SystemTime.High1Part    ^ (Teb->ClientId.UniqueProcess           << 16), sizeof(DWORD));
        dwXorshiftState[3] = Fnv1aDwordInline(RtlpUserShared()->InterruptTime.High1Part ^ (RtlpUserShared()->TickCount.High1Part << 16), sizeof(DWORD));
    }

    $DLOG1(DLG_FLT_DEFAULT, "Seed: 0x%016I64X`%016I64X", ((PQWORD)&dwXorshiftState)[0], ((PQWORD)&dwXorshiftState)[1]);
    $DLOG1(DLG_FLT_INFO, "Done");
}
